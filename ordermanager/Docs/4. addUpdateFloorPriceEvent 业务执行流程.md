
- [addUpdateFloorPriceEvent 业务执行流程详细分析](#addupdatefloorpriceevent-业务执行流程详细分析)
	- [1. 参数验证阶段](#1-参数验证阶段)
		- [1.1 订单ID验证](#11-订单id验证)
		- [1.2 价格验证](#12-价格验证)
		- [1.3 TokenID验证](#13-tokenid验证)
	- [2. 数据序列化阶段](#2-数据序列化阶段)
		- [2.1 事件序列化](#21-事件序列化)
	- [3. 队列操作阶段](#3-队列操作阶段)
		- [3.1 生成队列Key](#31-生成队列key)
		- [3.2 添加到队列](#32-添加到队列)
	- [4. 关键特性](#4-关键特性)

# addUpdateFloorPriceEvent 业务执行流程详细分析

## 1. 参数验证阶段

### 1.1 订单ID验证
```go
if event.EventType != Transfer && event.EventType != ImportCollection && event.EventType != UpdateCollection && event.OrderId == "" {
    return errors.New("invalid update collection floor price. event order id is null")
}
```
- 检查事件类型是否为Transfer/ImportCollection/UpdateCollection
- 如果不是这些类型，必须提供OrderId
- 返回错误信息

### 1.2 价格验证
```go
if event.EventType == Listing && event.Price.IsZero() {
    return errors.New("invalid update collection floor price. price is 0")
}
```
- 针对Listing事件的特殊验证
- 确保价格不为0
- 返回错误信息

### 1.3 TokenID验证
```go
if event.EventType == Listing && event.TokenID == "" {
    return errors.New("invalid update collection floor price. token_id is null")
}
```
- Listing事件必须提供TokenID
- 返回错误信息

## 2. 数据序列化阶段

### 2.1 事件序列化
```go
rawEvent, err := json.Marshal(event)
if err != nil {
    return errors.Wrap(err, "failed on marshal event")
}
```
- 将TradeEvent结构体序列化为JSON
- 处理序列化错误
- 返回错误信息

## 3. 队列操作阶段

### 3.1 生成队列Key
```go
key := genTradeEventsCacheKey(chain)
```
- 生成Redis队列key
- 格式为：`cache:trade:events:{chain}`

### 3.2 添加到队列
```go
if _, err := kv.Rpush(key, string(rawEvent)); err != nil {
    return errors.Wrap(err, "failed on push trade event to queue")
}
```
- 将序列化后的事件添加到Redis队列右侧
- 处理添加失败的情况
- 返回错误信息

## 4. 关键特性

1. **数据完整性**
   - 多重参数验证
   - 确保事件数据有效
   - 防止无效数据进入队列

2. **错误处理**
   - 每个步骤都有错误检查
   - 详细的错误信息
   - 便于问题追踪

3. **队列管理**
   - 使用Redis队列实现异步处理
   - 支持多链隔离
   - 保证消息不丢失

4. **性能考虑**
   - 异步处理避免阻塞
   - 批量操作支持
   - 高并发场景优化

这个流程确保了地板价更新事件的可靠处理，同时保持了系统的稳定性和性能。