


# OrderManager时间轮的作用与设计

## 1. 时间轮的核心作用

时间轮在OrderManager中主要用于**订单过期管理**，这是一种高效的定时任务实现方案。

### 1.1 为什么使用时间轮
- **性能考虑**：相比为每个订单创建一个定时器，时间轮只需要一个定时器轮询，极大减少系统开销
- **内存效率**：避免大量定时器对象造成的内存压力
- **精确控制**：可以精确到秒级管理订单过期时间

## 2. 时间轮工作原理

### 2.1 数据结构
```go
// 时间轮大小：3600（1小时一圈）
const WheelSize = 3600

type wheel struct {
    NotifyActivities *Order  // 链表存储任务
}

type Order struct {
    orderID        string
    CollectionAddr string
    ChainSuffix    string
    CycleCount     int64     // 需要循环的圈数
    WheelPosition  int64     // 在时间轮上的位置
    Next          *Order     // 链表指针
}
```

### 2.2 运行机制
1. **初始化**：启动时加载所有活跃订单到时间轮
2. **轮询检查**：每秒检查一次当前时间槽
3. **任务处理**：
   - 如果任务圈数为0，说明到期，执行过期处理
   - 如果圈数>0，圈数减1，继续等待

## 3. 订单处理流程

### 3.1 新订单加入
```go
func (om *OrderManager) addToOrderExpiryCheckQueue(delaySeconds int64, chainSuffix string, orderId string, collectionAddr string) error {
    // 计算时间轮位置和圈数
    calculateValue := om.CurrentIndex + delaySeconds
    cycle := calculateValue / WheelSize
    if cycle > 0 {
        cycle--
    }
    index := calculateValue % WheelSize
    
    // 创建订单任务
    orderActivity := &Order{
        orderID:        orderId,
        CollectionAddr: collectionAddr,
        ChainSuffix:    chainSuffix,
        CycleCount:     cycle,
        WheelPosition:  index,
    }
    
    // 插入到对应时间槽
    om.TimeWheel[index].NotifyActivities = orderActivity
}
```

### 3.2 过期检查
```go
func (om *OrderManager) orderExpiryProcess() {
    for {
        select {
        case <-time.After(time.Second):
            // 获取当前时间槽的任务
            taskLinkHead := om.TimeWheel[om.CurrentIndex].NotifyActivities
            
            // 遍历处理任务
            for p := taskLinkHead; p != nil; {
                if p.CycleCount == 0 {
                    // 订单过期，异步更新状态
                    go func() {
                        om.updateOrderState(p.orderID, p.CollectionAddr)
                    }()
                } else {
                    // 未过期，圈数减1
                    p.CycleCount--
                }
            }
            
            om.CurrentIndex++
        }
    }
}
```

## 4. 优势总结

1. **高效性**：
   - 单线程轮询，避免大量定时器开销
   - O(1)时间复杂度的任务插入和删除

2. **可靠性**：
   - 使用链表存储任务，动态管理内存
   - 异步处理过期订单，避免阻塞主循环

3. **可扩展性**：
   - 支持大量订单的过期管理
   - 可以通过调整WheelSize适应不同场景

这种设计使得OrderManager能够高效地管理大量订单的生命周期，是处理订单过期场景的理想方案。